package com.objetdirect.gwt.umldrawer.server.dao;import java.io.UnsupportedEncodingException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.google.appengine.repackaged.org.apache.commons.codec.binary.Base64;import com.objetdirect.gwt.umlapi.server.dao.DriverAccessor;//import com.google.gwt.dev.util.collect.HashMap;import com.objetdirect.gwt.umldrawer.client.beans.CheckItem;import com.objetdirect.gwt.umldrawer.client.beans.Comment;import com.objetdirect.gwt.umldrawer.client.beans.EditEvent;import com.objetdirect.gwt.umldrawer.client.beans.Exercise;import com.objetdirect.gwt.umldrawer.client.beans.OccurrenceReason;import com.objetdirect.gwt.umldrawer.client.beans.Reflection;import com.objetdirect.gwt.umldrawer.client.beans.Student;/**
 * @author J10-8011
 *
 */
public class Dao extends DriverAccessor {

	private Connection connection;
	public static final String UTF_8 = "UTF-8";	public static final String MS932 = "MS932";	public String ClassDiagramURL = new String();	//public List<String> removeURLList = new ArrayList<String>();	public Dao(){
	}

	public Student getStudent(String studentId) {		Student student = new Student();		this.connection = this.createConnection();
		try{

			String sql = "select * from student where student_id = ?";

			PreparedStatement stmt = this.connection.prepareStatement(sql);

			stmt.setString(1, studentId);
			ResultSet rs = stmt.executeQuery();			if(rs.first()){				student.setStudentId(rs.getString("student_id"));				student.setPassword(rs.getString("password"));				student.setType(rs.getInt("type"));			}			else{				this.closeConnection(this.connection);				return null;			}

		}catch(SQLException e){
			this.closeConnection(this.connection);
			e.printStackTrace();			return null;

		} finally {
		}		this.closeConnection(this.connection);

		return student;
	}	public List<String> getUserList() {		this.connection= this.createConnection();		List<String> userList = new ArrayList<String>();		try{			String sql = "select * from student";			PreparedStatement stmt = this.connection.prepareStatement(sql);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					userList.add(rs.getString("student_id"));				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return userList;	}	public void saveCanvas(String studentId, int exercisesId, String canvasUrl) {		this.connection= this.createConnection();		try{			String sql = "select * from canvas where student_id=? and exercises_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery(sql);			if(rs.first()){				sql = "update canvas set canvas_url = ? where student_id = ? and  exercises_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, canvasUrl);				stmt.setString(2, studentId);				stmt.setInt(3, exercisesId);				stmt.executeUpdate();				stmt.close();			}			else {				sql = "insert into canvas (student_id, exercises_id, canvas_url) values(?, ?, ?)";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, studentId);				stmt.setInt(2, exercisesId);				stmt.setString(3, canvasUrl);				stmt.executeUpdate();				stmt.close();			}			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);	}	public EditEvent loadCanvas(String studentId, int exercisesId) {		System.out.println("loadCanvas");		this.connection = this.createConnection();		EditEvent lastEvent=new EditEvent();		try{			//	String sql = "select * from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc";			String sql = "select * from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null and edit_event_id = (select max(edit_event_id) from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null)";			//from canvas table			//String sql = "select * from canvas where student_id = ' " + studentId+" ' and exercises_id = " + exercisesId ;			PreparedStatement stmt = this.connection.prepareStatement(sql);//			System.out.println("loadCanvas:"+sql.toString());			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			stmt.setString(3, studentId);			stmt.setInt(4, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				lastEvent.setCanvasUrl(rs.getString("canvas_url"));				lastEvent.setUmlArtifactId(rs.getInt("umlartifact_id"));			}			else{				System.out.println("loadCanvas rs.first()=false");				this.closeConnection(this.connection);				return null;			}		}catch(SQLException e){			this.closeConnection(this.connection);			e.printStackTrace();			return null;		} finally {		}		this.closeConnection(this.connection);		return lastEvent;	}	public List<String> getEditEvent(String studentId ,int exercisesId) {		this.connection= this.createConnection();		List<String> log = new ArrayList<String>();		try{			String sql = "select * from edit_event where student_id = ? and exercises_id = ? and canvas_url is not  null order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return log;	}	//canvas_urlがnullでない編集イベントのリストをget	public List<EditEvent> getEditEventList(String studentId, int exercisesId) {		this.connection= this.createConnection();		List<EditEvent> log = new ArrayList<EditEvent>();		try{			String sql = "select * from edit_event where student_id = ? and exercises_id = ?  and canvas_url is not null order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					EditEvent EV = new EditEvent();					EV.setEditEventId(rs.getInt("edit_event_id"));					EV.setStudentId(rs.getString("student_id"));					EV.setExercisesId(rs.getInt("exercises_id"));					EV.setPreEditEventId(rs.getInt("pre_event_id"));					EV.setEditEvent(rs.getString("edit_event"));					EV.setEventType(rs.getString("event_type"));					EV.setTargetType(rs.getString("target_type"));					EV.setTargetId(rs.getInt("target_id"));					EV.setRightObjectId(rs.getInt("right_object_id"));					EV.setLeftObjectId(rs.getInt("left_object_id"));					EV.setTargetPart(rs.getString("target_part"));					EV.setBeforeEdit(rs.getString("before_edit"));					EV.setAfterEdit(rs.getString("after_edit"));					EV.setCanvasId(rs.getInt("canvas_id"));					EV.setCanvasUrl(rs.getString("canvas_url"));					EV.setDifficulty(rs.getInt("difficulty"));					EV.setEditDatetime(rs.getTimestamp("edit_datetime"));					log.add(EV);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return log;	}	public EditEvent getEditEvent(int editEventId) {		this.connection= this.createConnection();		EditEvent EV = new EditEvent();		try{			String sql = "select * from edit_event where edit_event_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, editEventId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				EV.setEditEventId(rs.getInt("edit_event_id"));				EV.setStudentId(rs.getString("student_id"));				EV.setExercisesId(rs.getInt("exercises_id"));				EV.setPreEditEventId(rs.getInt("pre_event_id"));				EV.setEditEvent(rs.getString("edit_event"));				EV.setEventType(rs.getString("event_type"));				EV.setTargetType(rs.getString("target_type"));				EV.setTargetId(rs.getInt("target_id"));				EV.setRightObjectId(rs.getInt("right_object_id"));				EV.setLeftObjectId(rs.getInt("left_object_id"));				EV.setTargetPart(rs.getString("target_part"));				EV.setBeforeEdit(rs.getString("before_edit"));				EV.setAfterEdit(rs.getString("after_edit"));				EV.setCanvasId(rs.getInt("canvas_id"));				EV.setCanvasUrl(rs.getString("canvas_url"));				EV.setDifficulty(rs.getInt("difficulty"));				EV.setEditDatetime(rs.getTimestamp("edit_datetime"));			}			else {				EV = null;			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return EV;	}	public List<EditEvent> getAllEditEventList(String studentId, int exercisesId) {		this.connection= this.createConnection();		List<EditEvent> log = new ArrayList<EditEvent>();		try{			String sql = "select * from edit_event where student_id = ? and exercises_id = ?  order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					EditEvent EV = new EditEvent();					EV.setEditEventId(rs.getInt("edit_event_id"));					EV.setStudentId(rs.getString("student_id"));					EV.setExercisesId(rs.getInt("exercises_id"));					EV.setPreEditEventId(rs.getInt("pre_event_id"));					EV.setEditEvent(rs.getString("edit_event"));					EV.setEventType(rs.getString("event_type"));					EV.setTargetType(rs.getString("target_type"));					EV.setTargetId(rs.getInt("target_id"));					EV.setRightObjectId(rs.getInt("right_object_id"));					EV.setLeftObjectId(rs.getInt("left_object_id"));					EV.setTargetPart(rs.getString("target_part"));					EV.setBeforeEdit(rs.getString("before_edit"));					EV.setAfterEdit(rs.getString("after_edit"));					EV.setCanvasId(rs.getInt("canvas_id"));					EV.setCanvasUrl(rs.getString("canvas_url"));					EV.setDifficulty(rs.getInt("difficulty"));					EV.setEditDatetime(rs.getTimestamp("edit_datetime"));					log.add(EV);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return log;	}	//Replay用のイベントリストをゲット	public List<EditEvent> getEditEventListForReplay(String studentId ,int exercisesId) {		this.connection= this.createConnection();		List<EditEvent> log = new ArrayList<EditEvent>();		try{			String sql = "select * from edit_event where student_id = ? and exercises_id = ? and ( ( event_type='Check') or ( event_type='Place' and edit_event ='PlaceArtifacts')  or ( event_type='RemoveArtifacts' and edit_event ='RemoveArtifacts') or canvas_url is not null ) order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					EditEvent EV = new EditEvent();					EV.setEditEventId(rs.getInt("edit_event_id"));					EV.setStudentId(rs.getString("student_id"));					EV.setExercisesId(rs.getInt("exercises_id"));					EV.setPreEditEventId(rs.getInt("pre_event_id"));					EV.setEditEvent(rs.getString("edit_event"));					EV.setEventType(rs.getString("event_type"));					EV.setTargetType(rs.getString("target_type"));					EV.setTargetId(rs.getInt("target_id"));					EV.setRightObjectId(rs.getInt("right_object_id"));					EV.setLeftObjectId(rs.getInt("left_object_id"));					EV.setTargetPart(rs.getString("target_part"));					EV.setBeforeEdit(rs.getString("before_edit"));					EV.setAfterEdit(rs.getString("after_edit"));					EV.setCanvasId(rs.getInt("canvas_id"));					EV.setCanvasUrl(rs.getString("canvas_url"));					EV.setDifficulty(rs.getInt("difficulty"));					EV.setEditDatetime(rs.getTimestamp("edit_datetime"));					log.add(EV);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return log;	}	public void setDifficulty(int editEventId, int difficulty) {		this.connection = this.createConnection();		try{			String sql = "update edit_event set difficulty = ? ,edit_datetime=edit_datetime where edit_event_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, difficulty);			stmt.setInt(2, editEventId);			stmt.executeUpdate();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		}	}	public void addUser(String userId, String password) {		this.connection = this.createConnection();		try{			String sql = "insert into student (student_id,password,type) values(?,?,?)";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, userId);			stmt.setString(2, password);			stmt.setInt(3, 0);			stmt.executeUpdate();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		}	}	public void changePassword(String studentId, String password) {		this.connection = this.createConnection();		try{			String sql = "update student set password = ? where student_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, password);			stmt.setString(2, studentId);			stmt.executeUpdate();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		}	}	public List<EditEvent> getAllEditEventListDecoded(String studentId,			int exerciseId) throws UnsupportedEncodingException {		this.connection= this.createConnection();		List<EditEvent> log = new ArrayList<EditEvent>();		try{			String sql = "select * from edit_event where student_id = ? and exercises_id = ?  order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					EditEvent EV = new EditEvent();					EV.setEditEventId(rs.getInt("edit_event_id"));					EV.setStudentId(rs.getString("student_id"));					EV.setExercisesId(rs.getInt("exercises_id"));					EV.setPreEditEventId(rs.getInt("pre_event_id"));					EV.setEditEvent(rs.getString("edit_event"));					EV.setEventType(rs.getString("event_type"));					EV.setTargetType(rs.getString("target_type"));					EV.setTargetId(rs.getInt("target_id"));					EV.setRightObjectId(rs.getInt("right_object_id"));					EV.setLeftObjectId(rs.getInt("left_object_id"));					EV.setTargetPart(rs.getString("target_part"));					EV.setBeforeEdit(rs.getString("before_edit"));					EV.setAfterEdit(rs.getString("after_edit"));					EV.setCanvasId(rs.getInt("canvas_id"));					EV.setCanvasUrl(base64ToString(rs.getString("canvas_url")) );					EV.setDifficulty(rs.getInt("difficulty"));					EV.setEditDatetime(rs.getTimestamp("edit_datetime"));					log.add(EV);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return log;	}	private byte[] stringToBytes(String str) {		try {			//String -> byte[]			byte [] bytes = str.getBytes("UTF-8");  //String.getBytes();    or      String.getBytes(encoding);			//byte [] -> String			String xx = new String(bytes, "UTF-8"); //			return bytes;		} catch (UnsupportedEncodingException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();			return null;		}	}		public String base64ToString(String base64){		String decodedString=null;		if(base64!=null){			byte[] bytes = stringToBytes(base64);			byte[] decoded = Base64.decodeBase64(bytes);			try {				decodedString = new String(decoded, "UTF-8");			} catch (UnsupportedEncodingException e) {				e.printStackTrace();				return null;			}		}		return decodedString;	}	public String encodebase64ToString(String base64){		String encodedString=null;		if(base64!=null){			byte[] bytes = stringToBytes(base64);			byte[] encoded = Base64.encodeBase64(bytes);			try {				encodedString = new String(encoded, "UTF-8");			} catch (UnsupportedEncodingException e) {				e.printStackTrace();				return null;			}		}		return encodedString;	}	public EditEvent undo(String studentId, int exercisesId) {		this.connection= this.createConnection();		EditEvent backEvent = new EditEvent();		int editEventId=0;		try{			String sql = "select max(edit_event_id) from edit_event "					+ "where student_id = ? and exercises_id = ?"					+ " and ( ( event_type='Create' and canvas_url is not null) or ( event_type='Place' and edit_event ='PlaceArtifacts')  or ( event_type='RemoveArtifacts') or ( event_type='Edit') or ( event_type='Undo') )"					+ "and canvas_url is not null";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				editEventId= rs.getInt("max(edit_event_id)");				System.out.println("max(edit_event_id)="+editEventId);			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		backEvent.setEventType("NONE");;		do{			if(backEvent.getEventType().equals("Undo")){				editEventId = Integer.parseInt(backEvent.getEditEvent());			}			try{				String sql = "select * from edit_event where edit_event_id =("						+ "select max(edit_event_id) from edit_event where student_id = ? and exercises_id = ?"						+ " and (  (event_type='Start') or ( event_type='Create' and canvas_url is not null) or ( event_type='Place' and edit_event ='PlaceArtifacts')  or ( event_type='RemoveArtifacts') or ( event_type='Edit') or ( event_type='Undo') ) "						+ " and canvas_url is not null and edit_event_id <= ?"						+ ")";				PreparedStatement stmt = this.connection.prepareStatement(sql);				stmt.setString(1, studentId);				stmt.setInt(2, exercisesId);				stmt.setInt(3, editEventId);				ResultSet rs = stmt.executeQuery();				if(rs.first()){					backEvent.setEditEventId(rs.getInt("edit_event_id"));					backEvent.setStudentId(rs.getString("student_id"));					backEvent.setExercisesId(rs.getInt("exercises_id"));					backEvent.setPreEditEventId(rs.getInt("pre_event_id"));					backEvent.setEditEvent(rs.getString("edit_event"));					backEvent.setEventType(rs.getString("event_type"));					backEvent.setTargetType(rs.getString("target_type"));					backEvent.setTargetId(rs.getInt("target_id"));					backEvent.setRightObjectId(rs.getInt("right_object_id"));					backEvent.setLeftObjectId(rs.getInt("left_object_id"));					backEvent.setTargetPart(rs.getString("target_part"));					backEvent.setBeforeEdit(rs.getString("before_edit"));					backEvent.setAfterEdit(rs.getString("after_edit"));					backEvent.setCanvasId(rs.getInt("canvas_id"));					backEvent.setCanvasUrl(rs.getString("canvas_url"));					backEvent.setDifficulty(rs.getInt("difficulty"));					backEvent.setEditDatetime(rs.getTimestamp("edit_datetime"));					System.out.println("id="+backEvent.getEditEventId());					System.out.println("url="+backEvent.getCanvasUrl());				}			}catch(SQLException e){				//this.closeConnection(connection);				e.printStackTrace();			} finally {			}		}while ( backEvent.getEventType().equals("Undo") );		editEventId=backEvent.getEditEventId()-1;		try{			String sql = "select * from edit_event where edit_event_id =("					+ "select max(edit_event_id) from edit_event where student_id = ? and exercises_id = ?"					+ " and ( (event_type='Start') or ( event_type='Create' and canvas_url is not null) or  ( event_type='Place' and edit_event ='PlaceArtifacts')  or ( event_type='RemoveArtifacts') or ( event_type='Edit') or ( event_type='Undo')) "					+ " and canvas_url is not null and edit_event_id <= ?"					+ ")";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exercisesId);			stmt.setInt(3, editEventId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				backEvent.setEditEventId(rs.getInt("edit_event_id"));				backEvent.setStudentId(rs.getString("student_id"));				backEvent.setExercisesId(rs.getInt("exercises_id"));				backEvent.setPreEditEventId(rs.getInt("pre_event_id"));				backEvent.setEditEvent(rs.getString("edit_event"));				backEvent.setEventType(rs.getString("event_type"));				backEvent.setTargetType(rs.getString("target_type"));				backEvent.setTargetId(rs.getInt("target_id"));				backEvent.setRightObjectId(rs.getInt("right_object_id"));				backEvent.setLeftObjectId(rs.getInt("left_object_id"));				backEvent.setTargetPart(rs.getString("target_part"));				backEvent.setBeforeEdit(rs.getString("before_edit"));				backEvent.setAfterEdit(rs.getString("after_edit"));				backEvent.setCanvasId(rs.getInt("canvas_id"));				backEvent.setCanvasUrl(rs.getString("canvas_url"));				backEvent.setDifficulty(rs.getInt("difficulty"));				backEvent.setEditDatetime(rs.getTimestamp("edit_datetime"));				System.out.println("id="+backEvent.getEditEventId());				System.out.println("url="+backEvent.getCanvasUrl());			}		}catch(SQLException e){			//this.closeConnection(connection);			e.printStackTrace();		} finally {		}		if(backEvent.getEventType().equals("Undo")){			try{				String sql = "select * from edit_event where edit_event_id =?";				PreparedStatement stmt = this.connection.prepareStatement(sql);				stmt.setInt(1, Integer.parseInt(backEvent.getEditEvent()));				ResultSet rs = stmt.executeQuery();				if(rs.first()){					backEvent.setEditEventId(rs.getInt("edit_event_id"));					backEvent.setStudentId(rs.getString("student_id"));					backEvent.setExercisesId(rs.getInt("exercises_id"));					backEvent.setPreEditEventId(rs.getInt("pre_event_id"));					backEvent.setEditEvent(rs.getString("edit_event"));					backEvent.setEventType(rs.getString("event_type"));					backEvent.setTargetType(rs.getString("target_type"));					backEvent.setTargetId(rs.getInt("target_id"));					backEvent.setRightObjectId(rs.getInt("right_object_id"));					backEvent.setLeftObjectId(rs.getInt("left_object_id"));					backEvent.setTargetPart(rs.getString("target_part"));					backEvent.setBeforeEdit(rs.getString("before_edit"));					backEvent.setAfterEdit(rs.getString("after_edit"));					backEvent.setCanvasId(rs.getInt("canvas_id"));					backEvent.setCanvasUrl(rs.getString("canvas_url"));					backEvent.setDifficulty(rs.getInt("difficulty"));					backEvent.setEditDatetime(rs.getTimestamp("edit_datetime"));				}			}catch(SQLException e){				//this.closeConnection(connection);				e.printStackTrace();			} finally {			}		}		if(backEvent.getEventType().equals("Start")){			this.closeConnection(connection);			return null;		}		this.closeConnection(connection);		return backEvent;	}	public boolean saveCanvasAsAnswer(String studentId, int exerciseId, String canvasUrl) {		boolean flag = true; //for return		this.connection= this.createConnection();		try{			String sql = "select * from answer where exercise_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				sql = "update answer set canvas_url = ?, student_id = ? , entry_datetime = now() where exercise_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, canvasUrl);				stmt.setString(2, studentId);				stmt.setInt(3, exerciseId);				stmt.executeUpdate();				stmt.close();			}			else {				sql = "insert into answer (student_id, exercise_id, canvas_url, entry_datetime) values(?, ?, ?, now() )";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, studentId);				stmt.setInt(2, exerciseId);				stmt.setString(3, canvasUrl);				stmt.executeUpdate();				stmt.close();			}			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			flag = false;		} finally {		}		this.closeConnection(connection);		return flag;	}	public String getAnswer(int exerciseId) {		String canvasUrl = null;		this.connection= this.createConnection();		try{			String sql = "select * from answer where exercise_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				canvasUrl = rs.getString("canvas_url");			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return canvasUrl;	}		public boolean addExercise( String type, String title, String task ){		this.connection = this.createConnection();		try{			String sql = "insert into exercise (type, title ,task, entry_datetime, is_removed) values(?,?,?,now(), 0)";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, type);			stmt.setString(2, title);			stmt.setString(3, task);			stmt.executeUpdate();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			return false;		}		return true;	}	public List<Exercise> getExerciseList(String type) {		this.connection= this.createConnection();		List<Exercise> exerciseList = new ArrayList<Exercise>();		try{			String sql = "select * from exercise where type = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, type);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					Exercise ex = new Exercise();					ex.setExerciseId( rs.getInt("exercise_id"));					ex.setType( rs.getString("type"));					ex.setTitle( rs.getString("title"));					ex.setTask( rs.getString("task"));					ex.setEntryDatetime( rs.getDate("entry_datetime"));					ex.setIsRemoved( rs.getInt("is_removed"));					exerciseList.add(ex);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return exerciseList;	}	public Exercise getExercise(int exerciseId) {		this.connection= this.createConnection();		Exercise ex = new Exercise();		try{			String sql = "select * from exercise where exercise_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				ex.setExerciseId( rs.getInt("exercise_id"));				ex.setType( rs.getString("type"));				ex.setTitle( rs.getString("title"));				ex.setTask( rs.getString("task"));				ex.setEntryDatetime( rs.getDate("entry_datetime"));				ex.setIsRemoved( rs.getInt("is_removed"));			}			else{				return null;			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return ex;	}	public Comment addComment(int editEventId, String studentId, int exerciseId, String comment) {		this.connection= this.createConnection();		Comment newComment = new Comment();		ResultSet rs ;		try{			String sql = "select * from comment where edit_event_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, editEventId);			rs = stmt.executeQuery();			if(rs.first()){				int commentId = rs.getInt("comment_id");				sql = "update comment set comment = ? where comment_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, comment);				stmt.setInt(2, commentId);				stmt.executeUpdate();				stmt.close();			}			else {				sql = "insert into comment (edit_event_id, student_id, exercise_id, comment, entry_datetime ) values(?, ?, ?, ?, now())";				stmt = this.connection.prepareStatement(sql);				stmt.setInt(1, editEventId);				stmt.setString(2, studentId);				stmt.setInt(3, exerciseId);				stmt.setString(4, comment);				stmt.executeUpdate();				stmt.close();			}			sql = "select * from comment where comment_id = (select max(comment_id) from comment where edit_event_id = ?)";			stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, editEventId);			rs = stmt.executeQuery();			rs.first();			newComment.setCommentId( rs.getInt("comment_id") );			newComment.setEditEventId( rs.getInt("edit_event_id") );			newComment.setStudentId( rs.getString("student_id") );			newComment.setExerciseId( rs.getInt("exercise_id") );			newComment.setComment( rs.getString("comment") );			newComment.setEntryDatetime( rs.getDate("entry_datetime") );			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			return null;		} finally {		}		this.closeConnection(connection);		return newComment;	}	public List<Comment> getCommentList(String studentId, int exerciseId) {		this.connection= this.createConnection();		List<Comment> commentList = new ArrayList<Comment>();		try{			String sql = "select * from comment where student_id = ? and exercise_id = ? order by edit_event_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exerciseId);			ResultSet rs = stmt.executeQuery();			while(rs.next()){				Comment comment = new Comment();				comment.setCommentId( rs.getInt("comment_id") );				comment.setEditEventId( rs.getInt("edit_event_id") );				comment.setStudentId( rs.getString("student_id") );				comment.setExerciseId( rs.getInt("exercise_id") );				comment.setComment( rs.getString("comment") );				comment.setEntryDatetime( rs.getDate("entry_datetime") );				commentList.add(comment);			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return commentList;	}	public List<Reflection> getReflectionList(String studentId, int exerciseId) {		this.connection= this.createConnection();		List<Reflection> reflectionList = new ArrayList<Reflection>();		try{			String sql = "select * from reflection where student_id = ? and exercise_id = ? order by occurrence_point_id";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					Reflection rf = new Reflection();					rf.setReflectionId( rs.getInt("reflection_id"));					rf.setStudentId( rs.getString("student_id"));					rf.setExerciseId( rs.getInt("exercise_id"));					rf.setOccurrencePoint( getEditEvent( rs.getInt("occurrence_point_id") ) );					rf.setOtherReason( rs.getString("occurrence_reason"));					rf.setTargetPartIdList(stringToList( rs.getString("target_part")));					rf.setImagedSituation( rs.getString("imaged_situation"));					rf.setIsThereProblem( rs.getBoolean("is_there_problem"));					rf.setDiscoveredProblems( rs.getString("discovered_problem"));					rf.setEntryDatetime( rs.getTimestamp("entry_datetime"));					reflectionList.add(rf);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return reflectionList;	}	public List<OccurrenceReason> getOccurrenceReasonList(int reflectionId) {		this.connection= this.createConnection();		List<Integer> ORIdList = new ArrayList<Integer>();		List<OccurrenceReason> ORList = new ArrayList<OccurrenceReason>();		try{			String sql = "select * from reflection_reason where reflection_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflectionId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					ORIdList.add( rs.getInt("occurrence_reason_id") );				}while(rs.next());				for(int id : ORIdList){					sql = "select * from occurrence_reason where occurrence_reason_id = ?";					stmt = this.connection.prepareStatement(sql);					stmt.setInt(1, id);					rs = stmt.executeQuery();					if(rs.first()){						do{							OccurrenceReason or = new OccurrenceReason();							or.setReasonId(rs.getInt("occurrence_reason_id"));							or.setReason(rs.getString("occurrence_reason"));							ORList.add(or);						}while(rs.next());					}				}			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return ORList;	}	public List<CheckItem> getCheckItemList(int reflectionId) {		this.connection= this.createConnection();		List<Integer> CIIdList = new ArrayList<Integer>();		List<CheckItem> CIList = new ArrayList<CheckItem>();		try{			String sql = "select * from reflection_check_item where reflection_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflectionId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					CIIdList.add( rs.getInt("check_item_id") );				}while(rs.next());				for(int id : CIIdList){					sql = "select * from check_item where check_item_id = ?";					stmt = this.connection.prepareStatement(sql);					stmt.setInt(1, id);					rs = stmt.executeQuery();					if(rs.first()){						do{							CheckItem ci = new CheckItem();							ci.setCheckItemId(rs.getInt("check_item_id"));							ci.setCheckItem(rs.getString("check_item"));							CIList.add(ci);						}while(rs.next());					}				}			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return CIList;	}	public List<EditEvent> getModificationEventList(int reflectionId) {		this.connection= this.createConnection();		List<Integer> EIdList = new ArrayList<Integer>();		List<EditEvent> EList = new ArrayList<EditEvent>();		try{			String sql = "select * from modification_event where reflection_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflectionId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					EIdList.add( rs.getInt("edit_event_id") );				}while(rs.next());				for(int id : EIdList){					EList.add( this.getEditEvent(id) );				}			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return EList;	}	public Reflection addReflection(Reflection newReflection) {		this.connection= this.createConnection();		ResultSet rs ;		try{			System.out.println("Dao newReflection.id="+newReflection.getReflectionId());			String sql = "select * from reflection where reflection_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, newReflection.getReflectionId());			rs = stmt.executeQuery();			if(rs.first()){				int reflectionId = rs.getInt("reflection_id");				sql = "update reflection set occurrence_reason = ? , target_part = ? , imaged_situation = ? , is_there_problem = ? , discovered_problem = ? , entry_datetime = now()  where reflection_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, newReflection.getOtherReason());				stmt.setString(2, listToString(newReflection.getTargetPartIdList()  )   );//				stmt.setString(3, newReflection.getImagedSituation());				stmt.setBoolean(4, newReflection.isThereProblem());				stmt.setString(5, newReflection.getDiscoveredProblems());				stmt.setInt(6, reflectionId);				stmt.executeUpdate();				stmt.close();			}			else {				sql = "insert into reflection (student_id, exercise_id, occurrence_point_id, occurrence_reason, target_part, imaged_situation, is_there_problem, discovered_problem, entry_datetime ) "						+ "values(?, ?, ?, ?, ?, ?, ?, ?, now())";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, newReflection.getStudentId());				stmt.setInt(2, newReflection.getExerciseId());				stmt.setInt(3, newReflection.getOccurrencePoint().getEditEventId());				stmt.setString(4, newReflection.getOtherReason());				stmt.setString(5,  listToString( newReflection.getTargetPartIdList() ) );//				stmt.setString(6, newReflection.getImagedSituation());				stmt.setBoolean(7, newReflection.isThereProblem());				stmt.setString(8, newReflection.getDiscoveredProblems());				stmt.executeUpdate();				stmt.close();				sql = "select * from reflection where reflection_id = (select max(reflection_id) from reflection where student_id = ? and exercise_id = ?)";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, newReflection.getStudentId());				stmt.setInt(2, newReflection.getExerciseId());				rs = stmt.executeQuery();				rs.first();				newReflection.setReflectionId( rs.getInt("reflection_id") );				newReflection.setEntryDatetime( rs.getTimestamp("entry_datetime") );				stmt.close();			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			return null;		} finally {		}		this.closeConnection(connection);		return newReflection;	}	public boolean removeReflection(Reflection reflection) {		this.connection= this.createConnection();		try{			String sql = "delete from reflection where reflection_id = ?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflection.getReflectionId());			stmt.executeUpdate();			sql = "delete from reflection_reason where reflection_id = ?";			stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflection.getReflectionId());			stmt.executeUpdate();			sql = "delete from reflection_check_item where reflection_id = ?";			stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflection.getReflectionId());			stmt.executeUpdate();			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			return false;		} finally {		}		this.closeConnection(connection);		return true;	}	//OccurrenceReason	public void addOccurrenceReason(Reflection reflection){		this.connection= this.createConnection();		List<OccurrenceReason> reasonList = reflection.getReasonList();		try{			String sql = "delete from reflection_reason where reflection_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflection.getReflectionId());			stmt.executeUpdate();			for(OccurrenceReason or  : reasonList){				sql = "insert into reflection_reason (reflection_id, occurrence_reason_id ) values(?, ?)";				stmt = this.connection.prepareStatement(sql);				stmt.setInt(1, reflection.getReflectionId());				stmt.setInt(2, or.getReasonId());				stmt.executeUpdate();			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);	}	//checkItem	public void addCheckItem(Reflection reflection){		this.connection= this.createConnection();		List<CheckItem>checkItemList = reflection.getCheckedItemList();		try{			String sql = "delete from reflection_check_item where reflection_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, reflection.getReflectionId());			stmt.executeUpdate();			for(CheckItem ci  : checkItemList){				sql = "insert into reflection_check_item (reflection_id, check_item_id ) values(?, ?)";				stmt = this.connection.prepareStatement(sql);				stmt.setInt(1, reflection.getReflectionId());				stmt.setInt(2, ci.getCheckItemId());				stmt.executeUpdate();			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);	}	public List<Integer> stringToList(String str) {		String[] tmp = str.split(",");		List<Integer> ans = new ArrayList<Integer>();		for(int i=0 ; i<tmp.length ; i++){			if(tmp[i].equals("")) break;			ans.add( Integer.parseInt(tmp[i]) );		}		return ans;	}	public String listToString(List<Integer> list) {		StringBuilder sb = new StringBuilder();		for( int id : list){			sb.append(Integer.toString(id)+",");		}		sb.toString();		return sb.toString();	}	public void addModificationEvent(Reflection newReflection) {		this.connection= this.createConnection();		List<EditEvent>modificationEventList = newReflection.getModificationEventList();		try{			String sql = "delete from modification_event where reflection_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, newReflection.getReflectionId());			stmt.executeUpdate();			for(EditEvent ev  : modificationEventList){				sql = "insert into modification_event (reflection_id, edit_event_id ) values(?, ?)";				stmt = this.connection.prepareStatement(sql);				stmt.setInt(1, newReflection.getReflectionId());				stmt.setInt(2, ev.getEditEventId());				stmt.executeUpdate();			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);	}	public List<OccurrenceReason> getAllOccurrenceReasonList() {		this.connection= this.createConnection();		List<OccurrenceReason> ORList = new ArrayList<OccurrenceReason>();		try{			String sql = "select * from occurrence_reason";			PreparedStatement stmt = this.connection.prepareStatement(sql);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					OccurrenceReason or = new OccurrenceReason();					or.setReasonId(rs.getInt("occurrence_reason_id"));					or.setReason(rs.getString("occurrence_reason"));					ORList.add(or);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return ORList;	}	public List<CheckItem> getAllCheckItemList() {		this.connection= this.createConnection();		List<CheckItem> CIList = new ArrayList<CheckItem>();		try{			String sql = "select * from check_item";			PreparedStatement stmt = this.connection.prepareStatement(sql);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					CheckItem ci = new CheckItem();					ci.setCheckItemId(rs.getInt("check_item_id"));					ci.setCheckItem(rs.getString("check_item"));					CIList.add(ci);				}while(rs.next());			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return CIList;	}	public List<Student> getUserListForReplay(int exerciseId) {		this.connection= this.createConnection();		List<Student> userList = new ArrayList<Student>();		try{			//String sql = "select * from student";			String sql = "select distinct student.student_id, student.password, student.type from student left outer join edit_event on student.student_id = edit_event.student_id where exercises_id = ? and canvas_url is not null order by student.student_id asc";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setInt(1, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				do{					Student s = new Student();					s.setStudentId( rs.getString("student_id") );					s.setPassword( rs.getString("password") );					s.setType( rs.getInt("type") );					userList.add(s);				}while(rs.next());			}/*			for(int i=0 ; i<userList.size(); i++){				sql = "select * from edit_event where student_id = ? and exercises_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setString( 1, userList.get(i).getStudentId() );				stmt.setInt( 2, exerciseId );				rs = stmt.executeQuery();				if(!rs.first()){					userList.set(i, null);				}			}			userList.removeAll(Collections.singleton(null));*/		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return userList;	}	public boolean setAdmin(String text, boolean isAdmin) {		this.connection= this.createConnection();		ResultSet rs ;		boolean r;		try{			String sql = "select * from student where student_id=?";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, text);			rs = stmt.executeQuery();			if(rs.first()){				sql = "update student set type = ? where student_id = ?";				stmt = this.connection.prepareStatement(sql);				stmt.setBoolean(1, isAdmin);				stmt.setString(2, text);				stmt.executeUpdate();				stmt.close();				r = true;			}			else {				r = false;			}		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();			r =  false;		} finally {		}		this.closeConnection(connection);		return r;	}	public void updateCheckItem(List<CheckItem> checkItemList) {		this.connection= this.createConnection();		try{			String sql = "delete from check_item";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.executeUpdate();			for(CheckItem ci  : checkItemList){				sql = "insert into check_item (check_item ) values(?)";				stmt = this.connection.prepareStatement(sql);				stmt.setString(1, ci.getCheckItem());				stmt.executeUpdate();			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);	}	public void setExerciseRemoved(int exerciseId, Boolean isRemoved){		this.connection= this.createConnection();		String sql = "update exercise set is_removed = ? where exercise_id = ?";		PreparedStatement stmt;		try {			stmt = this.connection.prepareStatement(sql);			stmt.setBoolean(1, isRemoved);			stmt.setInt(2, exerciseId);			stmt.executeUpdate();			stmt.close();			this.closeConnection(connection);		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();			this.closeConnection(connection);		} finally{			this.closeConnection(connection);		}		return;	}	public void prepareExperimentalData(String userId) {	}//拡張部分	//**************************************************************************************************	//パターンのリストをデータベースから取得	public List<String> getPatternNameList() {		System.out.println("getPatternNameList");		List<String> list = new ArrayList<String>();		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "SELECT pattern_name FROM test_pattern";			psmt = this.connection.prepareStatement(sql);			rs = psmt.executeQuery();			while (rs.next()) {				list.add(rs.getString("pattern_name"));			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		} finally {			this.closeConnection(connection);		}		return list;	}	//パターンのスポット部をデータベースから取得	public List<String> getPatternSpotList(int listIndex) {		List<String> list = new ArrayList<String>();		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "SELECT spot_name FROM test_spot where pattern_id = ?";			psmt = this.connection.prepareStatement(sql);			psmt.setInt(1, listIndex);			rs = psmt.executeQuery();			while (rs.next()) {				list.add(rs.getString("spot_name"));			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		} finally {			this.closeConnection(connection);		}		System.out.println(listIndex + "" + list);		return list;	}	//既存のクラス図のリストをデータベースから取得	public List<String> getUMLClassDiagramList(String studentId, int exercisesId) {		System.out.println("getUMLClassDiagramList");		List<String> list = new ArrayList<String>();		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "select canvas_url from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc limit 1";			psmt = this.connection.prepareStatement(sql);			psmt.setString(1, studentId);			psmt.setInt(2, exercisesId);			rs = psmt.executeQuery();						System.out.println(rs);			while(rs.next()) {				String result = base64ToString(rs.getString("canvas_url"));								System.out.println(result);				//				setClassDiagramURL(result);				if( ! (result.equals(null))) {		    		String[] URLSplit = result.split(";", 0);		    		System.out.println(URLSplit);		    		for(int i = 0; i < URLSplit.length; i ++) {		    			System.out.println("@"+URLSplit[i]);		    			int index1 = URLSplit[i].indexOf("!");		    			System.out.println("*"+URLSplit[i]);		    			int index2 = URLSplit[i].indexOf("!", index1+1);		    					    					    			if(index1 != -1 && index2 != -1 && !(URLSplit[i].substring(index1+1, index2).contains("<"))) {		    				System.out.println(URLSplit[i].substring(index1+1, index2));		    				list.add(URLSplit[i].substring(index1+1, index2));		    			}			    		/*		    			else {			    			int xxx = zzz[i].indexOf("!");			    			int yyy = zzz[i].indexOf("!!!", xxx+1);			    			if(xxx != -1 && yyy != -1 && !(zzz[i].substring(xxx+1, yyy).contains("<"))) {			    				list.add(zzz[i].substring(xxx+1, yyy));			    			}		    			}*/		    		}				}			}			rs.close();			psmt.close();		} catch (SQLException e) {			e.printStackTrace();		} finally {			this.closeConnection(connection);		}		System.out.println(list);				return list;	}	//合成機能_ver1	public String getCombineUrl(String studentId, int exercisesId, int index, String selectClass, String spotName) {		String url = new String();		String encodeUrl = new String();		String uMLDiagramUrl = new String();		String patternUrl = new String();		StringBuilder builder = new StringBuilder();		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "select canvas_url from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc limit 1";			psmt = this.connection.prepareStatement(sql);			psmt.setString(1, studentId);			psmt.setInt(2, exercisesId);			rs = psmt.executeQuery();			while(rs.next()) {				String result = base64ToString(rs.getString("canvas_url"));				if(result != null) {					uMLDiagramUrl = result;				}			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		}		try {			String sql = "SELECT pattern_url FROM pattern_list where pattern_id = ?";			psmt = this.connection.prepareStatement(sql);			psmt.setInt(1, index);			rs = psmt.executeQuery();			while(rs.next()) {				String result = base64ToString(rs.getString("pattern_url"));				if(result != null) {					patternUrl = result;				}			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		} finally {			this.closeConnection(connection);		}		if(uMLDiagramUrl != null && patternUrl != null) {			String uMLDiagramUrlSplit[] = uMLDiagramUrl.split(";", 0);			String lastUMLDiagramUrl = uMLDiagramUrlSplit[uMLDiagramUrlSplit.length-1];			int indexA = lastUMLDiagramUrl.indexOf("<");			int indexB = lastUMLDiagramUrl.indexOf(">");			//System.out.println("indexA = " + index1 + "," + "indexB = " + index2);			int lastUMLId = Integer.parseInt(lastUMLDiagramUrl.substring(indexA+1, indexB)) + 1;			String patternUrlSplit[] = patternUrl.split(";", 0);			for (int i = 0; i < patternUrlSplit.length; i ++) {				if(patternUrlSplit[i].contains("<")) {					int index1 = patternUrlSplit[i].indexOf("<");					int index2 = patternUrlSplit[i].indexOf(">");					System.out.println("indexA = " + index1 + "," + "indexB = " + index2);					String ArtifactId = patternUrlSplit[i].substring(index1+1, index2);					System.out.println("ArtifactId = " + ArtifactId + ", lastUMLId = " + lastUMLId);				    Pattern p = Pattern.compile(ArtifactId);				    Matcher m = p.matcher(patternUrlSplit[i]);				    patternUrlSplit[i] = m.replaceFirst(String.valueOf(lastUMLId));				    for(int j = 0; j < patternUrlSplit.length; j ++) {				    	if(patternUrlSplit[j].contains(ArtifactId)) {						    Pattern p2 = Pattern.compile(ArtifactId);						    Matcher m2 = p2.matcher(patternUrlSplit[j]);						    patternUrlSplit[j] = m2.replaceFirst(String.valueOf(lastUMLId));				    	}				    }				    lastUMLId += 1;				    System.out.println("patternUrlSplit = " + patternUrlSplit[i]);				}			}			for(int i = 0; i < patternUrlSplit.length; i ++) {				if(patternUrlSplit[i] != ""){					builder.append(patternUrlSplit[i]);					builder.append(";");				}			}			patternUrl = builder.toString();			System.out.println(uMLDiagramUrl);			builder.setLength(0);			url = "" + uMLDiagramUrl + "" + patternUrl;			System.out.println(url);			String replaceId = new String();			String targetId = new String();			String uMLSplit[] = url.split(";", 0);			for(int i = 0; i < uMLSplit.length; i ++) {				//合成元となるパターンクラスを削除				if(uMLSplit[i].contains(spotName)) {					int index1 = uMLSplit[i].indexOf("<");					int index2 = uMLSplit[i].indexOf(">");					System.out.println("index1 = " + index1 + ", index2 = " + index2 + ", " + "selectClass = " + selectClass);					if(index1 != -1 && index2 != -1) {						replaceId = uMLSplit[i].substring(index1, index2+1);						System.out.println("replaceId = " + replaceId);					}					uMLSplit[i] = "";				}				//合成させたいクラスのidを取得				if(uMLSplit[i].contains(selectClass)) {					int index1 = uMLSplit[i].indexOf("<");					int index2 = uMLSplit[i].indexOf(">");					if(index1 != -1 && index2 != -1) {						targetId = uMLSplit[i].substring(index1, index2+1);					}					System.out.println("targetId = " + targetId);					//zzz[i] = "" + targetId;				}				System.out.println(uMLSplit[i]);			}			//関連先のクラスを変更			for(int i = 0; i < uMLSplit.length; i ++) {				if(uMLSplit[i].contains(replaceId)) {					System.out.println("replaceId = " + replaceId + ", targetId = " + targetId);				    Pattern p = Pattern.compile(replaceId);				    Matcher m = p.matcher(uMLSplit[i]);				    uMLSplit[i] = m.replaceFirst(targetId);					System.out.println("uMLSplit = " + uMLSplit[i]);				}			}			//再び組み立て			for(int i = 0; i < uMLSplit.length; i ++) {				if(uMLSplit[i] != ""){					builder.append(uMLSplit[i]);					builder.append(";");				}			}			url = builder.toString();			System.out.println(url);			encodeUrl = encodebase64ToString(url);		}		return encodeUrl;	}	//合成機能_ver2 	public String getCombineUrl2(String studentId, int exercisesId, int listindex, Map<String, String> combineMap) {		String combineURL = new String();		String encodeURL = new String();		String classDiagramURL = new String();		String patternURL = new String();		List<String> mapKey = new ArrayList<String>(combineMap.keySet());		List<String> mapValue = new ArrayList<String>(combineMap.values());		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "select canvas_url from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc limit 1";			psmt = this.connection.prepareStatement(sql);			psmt.setString(1, studentId);			psmt.setInt(2, exercisesId);			rs = psmt.executeQuery();			while(rs.next()) {				String result = base64ToString(rs.getString("canvas_url"));				if(result != null) {					classDiagramURL = result;				}			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		}		try {			String sql = "SELECT pattern_url FROM test_pattern where pattern_id = ?";			psmt = this.connection.prepareStatement(sql);			psmt.setInt(1, listindex);			rs = psmt.executeQuery();			while(rs.next()) {				String result = base64ToString(rs.getString("pattern_url"));				if(result != null) {					patternURL = result;				}			}			rs.close();			psmt.close();		} catch (SQLException e) {			// TODO 自動生成された catch ブロック			e.printStackTrace();		} finally {			this.closeConnection(connection);		}		if( ! (classDiagramURL.equals("")) && ! (patternURL.equals(""))) {			patternURL = getChangeUMLArtifactIdList(patternURL, classDiagramURL);			combineURL = "" + classDiagramURL + "" + patternURL;			Map<String, String> replaceIdMap = new HashMap<String, String>();			replaceIdMap.putAll(getReplaceIdMap(combineURL, combineMap));			List<String> replaceIdList = new ArrayList<String>(replaceIdMap.keySet());			System.out.println("replaceIdMap : " + replaceIdMap);			Map<String, String> attributeMap = new HashMap<String, String>();			attributeMap.putAll(getAttributeMap(patternURL, replaceIdList, combineMap));			System.out.println("attributeMap : " + attributeMap);			Map<String, String> operationMap = new HashMap<String, String>();			operationMap.putAll(getOperationMap(patternURL, replaceIdList, combineMap));			System.out.println("operationMap : " + operationMap);			patternURL = removePatternURL(patternURL, mapKey);			//List<String> targetIdList = new ArrayList<String>(getTargetIdList(classDiagramURL, mapValue));			//System.out.println("targetIdList : " + targetIdList);			if( ! (attributeMap.isEmpty()) || ! (operationMap.isEmpty())) {				classDiagramURL = addAttributeAndOperation(classDiagramURL, mapValue, attributeMap, operationMap);			}			combineURL = "" + classDiagramURL + "" + patternURL;			System.out.println(combineURL);			combineURL = getChangedCombineURL(combineURL, replaceIdMap);			System.out.println(combineURL);			encodeURL = encodebase64ToString(combineURL);		}		return encodeURL;	}	//UMLArtifactIdを既存のクラス図のクラスに合わせる	private String getChangeUMLArtifactIdList(String patternURL, String classDiagramURL) {		String classDiagramURLSplit[] = classDiagramURL.split(";", 0);		String lastClassDiagramURL = classDiagramURLSplit[classDiagramURLSplit.length-1];		int indexA = lastClassDiagramURL.indexOf("<");		int indexB = lastClassDiagramURL.indexOf(">");		//System.out.println("indexA = " + index1 + "," + "indexB = " + index2);		int lastUMLId = Integer.parseInt(lastClassDiagramURL.substring(indexA+1, indexB)) + 1;		String patternURLSplit[] = patternURL.split(";", 0);		for (int i = 0; i < patternURLSplit.length; i ++) {			if(patternURLSplit[i].contains("<")) {				int index1 = patternURLSplit[i].indexOf("<");				int index2 = patternURLSplit[i].indexOf(">");				System.out.println("indexA = " + index1 + "," + "indexB = " + index2);				String ArtifactId = patternURLSplit[i].substring(index1+1, index2);			    Pattern p = Pattern.compile(ArtifactId);			    Matcher m = p.matcher(patternURLSplit[i]);			    patternURLSplit[i] = m.replaceFirst(String.valueOf(lastUMLId));			    for(int j = 0; j < patternURLSplit.length; j ++) {			    	if(patternURLSplit[j].contains(ArtifactId)) {					    Pattern p2 = Pattern.compile(ArtifactId);					    Matcher m2 = p2.matcher(patternURLSplit[j]);					    patternURLSplit[j] = m2.replaceFirst(String.valueOf(lastUMLId));			    	}			    }			    lastUMLId += 1;			    //System.out.println("patternURLSplit = " + patternURLSplit[i]);			}		}		patternURL = getBuilderURL(patternURLSplit);		return patternURL;	}	//URLを組み立てる	private String getBuilderURL(String[] splitURL) {		String builderURL = new String();		StringBuilder builder = new StringBuilder();		for(int i = 0; i < splitURL.length; i ++) {			if(! (splitURL[i].equals(""))){				builder.append(splitURL[i]);				builder.append(";");			}		}		builderURL = builder.toString();		System.out.println(builderURL);		return builderURL;	}	//合成元のクラス(選択されたパターンのホットスポット)のIDを取得する	private Map<String, String> getReplaceIdMap(String combineURL, Map<String, String> combineMap) {		String [] combineURLSplit = combineURL.split(";", 0);		Map<String, String> replaceIdMap = new HashMap<String, String>();		for(int i = 0; i < combineURLSplit.length; i ++) {			for(Map.Entry<String, String> entry : combineMap.entrySet()) {				String replaceId = new String();				String targetId = new String();				String spotName = new String();				int index1 = combineURLSplit[i].indexOf("!");				int index2 = combineURLSplit[i].indexOf("!", index1+1);				if(index1 != -1 && index2 != -1 && !(combineURLSplit[i].substring(index1+1, index2).contains("<"))) {					spotName = combineURLSplit[i].substring(index1+1, index2);				}				//合成元となるパターンクラスを削除				System.out.println("combineURLSplit = " + combineURLSplit[i] + ", mapKey = " + entry.getKey() + ", spotName = " + spotName);				if(spotName.equals(entry.getKey())) {					index1 = combineURLSplit[i].indexOf("<");					index2 = combineURLSplit[i].indexOf(">");					System.out.println("index1 = " + index1 + ", index2 = " + index2);					if(index1 != -1 && index2 != -1) {						replaceId = combineURLSplit[i].substring(index1, index2+1);					}					for(int j = 0; j < combineURLSplit.length; j ++) {						String className = new String();						index1 = combineURLSplit[j].indexOf("!");						index2 = combineURLSplit[j].indexOf("!", index1+1);						if(index1 != -1 && index2 != -1 && !(combineURLSplit[j].contains("ClassRelationLink"))) {							className = combineURLSplit[j].substring(index1+1, index2);						}						if(className.equals(entry.getValue())) {							index1 = combineURLSplit[j].indexOf("<");							index2 = combineURLSplit[j].indexOf(">");							System.out.println("index1 = " + index1 + ", index2 = " + index2);							if(index1 != -1 && index2 != -1) {								targetId = combineURLSplit[j].substring(index1, index2+1);							}						}					}				}				if( ! (replaceId.equals("")) && ! (targetId.equals(""))) {					System.out.println("replaceId : " + replaceId + ", targetId : " + targetId);					replaceIdMap.put(replaceId, targetId);				}			}		}		return replaceIdMap;	}	//選択されたホットスポットの属性を抽出	private Map<String, String> getAttributeMap(String patternURL, List<String> replaceIdList, Map<String, String> combineMap) {		Map<String, String> attributeMap = new HashMap<String, String>();		String[] patternURLSplit = patternURL.split(";", 0);		for(int i = 0; i < patternURLSplit.length; i ++) {			for(int j = 0; j < replaceIdList.size(); j ++) {				String artifactId = new String();				int index1 = patternURLSplit[i].indexOf("<");				int index2 = patternURLSplit[i].indexOf(">");				if(index1 != -1 && index2 != -1) {					artifactId = patternURLSplit[i].substring(index1, index2+1);				}				if(artifactId.equals(replaceIdList.get(j))) {					String[] patternURLSplit2 = patternURLSplit[i].split("!", 0);					index1 = 0;					index2 = 0;					for(int k = 0; k < patternURLSplit2.length; k ++) {						if( ! (patternURLSplit2[k].contains("%")) || patternURLSplit2[k].contains("("))	continue;						else {};						/*						if(patternURLSplit2[k].startsWith("+")) {							index1 = patternURLSplit2[k].indexOf("+");						}						else if(patternURLSplit2[k].startsWith("-")) {							index1 = patternURLSplit2[k].indexOf("-");						}						else if(patternURLSplit2[k].startsWith("#")) {							index1 = patternURLSplit2[k].indexOf("#");						}						else if(patternURLSplit2[k].startsWith("~")) {							index1 = patternURLSplit2[k].indexOf("~");						}						*/						index2 = patternURLSplit2[k].lastIndexOf("%");						if(index1 != -1 && index2 != -1) {							attributeMap.put(combineMap.get(patternURLSplit2[1]), patternURLSplit2[k].substring(index1, index2+1));							System.out.println("属性：" + patternURLSplit2[k].substring(index1, index2+1));						}					}				}			}		}		return attributeMap;	}	//選択されたホットスポットのクラスの操作を抽出	private Map<String, String> getOperationMap(String patternURL, List<String> replaceIdList, Map<String, String> combineMap) {		Map<String, String> operationMap = new HashMap<String, String>();		String[] patternURLSplit = patternURL.split(";", 0);		for(int i = 0; i < patternURLSplit.length; i ++) {			for(int j = 0; j < replaceIdList.size(); j ++) {				String artifactId = new String();				int index1 = patternURLSplit[i].indexOf("<");				int index2 = patternURLSplit[i].indexOf(">");				if(index1 != -1 && index2 != -1) {					artifactId = patternURLSplit[i].substring(index1, index2+1);				}				if(artifactId.equals(replaceIdList.get(j))) {					String[] patternURLSplit2 = patternURLSplit[i].split("!", 0);					index1 = 0;					index2 = 0;					for(int k = 0; k < patternURLSplit2.length; k ++) {						if( ! (patternURLSplit2[k].contains("%")) || ! (patternURLSplit2[k].contains("("))) 	continue;						else {};						/*						if(patternURLSplit2[k].startsWith("+")) {							index1 = patternURLSplit2[k].indexOf("+");						}						else if(patternURLSplit2[k].startsWith("-")) {							index1 = patternURLSplit2[k].indexOf("-");						}						else if(patternURLSplit2[k].startsWith("#")) {							index1 = patternURLSplit2[k].indexOf("#");						}						else if(patternURLSplit2[k].startsWith("~")) {							index1 = patternURLSplit2[k].indexOf("~");						}						*/						index2 = patternURLSplit2[k].lastIndexOf("%");						if(index1 != -1 && index2 != -1) {							operationMap.put(combineMap.get(patternURLSplit2[1]), patternURLSplit2[k].substring(index1, index2+1));							System.out.println("操作：" + patternURLSplit2[k].substring(index1, index2+1));						}					}				}			}		}		return operationMap;	}	//選択されたホットスポットのクラスを削除する	private String removePatternURL(String patternURL, List<String> mapKey) {		String [] patternURLSplit = patternURL.split(";", 0);		for(int i = 0; i < patternURLSplit.length; i ++) {			for(int j = 0; j < mapKey.size(); j ++) {				String className = new String();				int index1 = patternURLSplit[i].indexOf("!");				int index2 = patternURLSplit[i].indexOf("!", index1+1);				if(index1 != -1 && index2 != -1 && !(patternURLSplit[i].substring(index1+1, index2).contains("<"))) {					className = patternURLSplit[i].substring(index1+1, index2);				}				if(className.equals(mapKey.get(j))) {					patternURLSplit[i] = "";				}			}		}		patternURL = getBuilderURL(patternURLSplit);		return patternURL;	}	//合成させたいクラス(選択された既存のクラス)のIDを取得	private List<String> getTargetIdList(String classDiagramURL, List<String> mapValue) {		String [] classDiagramURLSplit = classDiagramURL.split(";", 0);		List<String> targetIdList = new ArrayList<String>();		for(int i = 0; i < classDiagramURLSplit.length; i ++) {			for(int j = 0; j < mapValue.size(); j ++) {				String className = new String();				int index1 = classDiagramURLSplit[i].indexOf("!");				int index2 = classDiagramURLSplit[i].indexOf("!", index1+1);				if(index1 != -1 && index2 != -1 && !(classDiagramURLSplit[i].substring(index1+1, index2).contains("<"))) {					className = classDiagramURLSplit[i].substring(index1+1, index2);				}				System.out.println("combineURLSplit = " + classDiagramURLSplit[i] + ", mapValue = " + mapValue.get(j));				if(className.equals(mapValue.get(j))) {					index1 = classDiagramURLSplit[i].indexOf("<");					index2 = classDiagramURLSplit[i].indexOf(">");					if(index1 != -1 && index2 != -1) {						targetIdList.add(classDiagramURLSplit[i].substring(index1, index2+1));					}				}			}		}		return targetIdList;	}	//合成させるクラスにホットスポットの属性・メソッドを追加	private String addAttributeAndOperation(String classDiagramURL, List<String> mapValue, Map<String, String> attributeMap, Map<String, String> operationMap) {		String[] classDiagramURLSplit = classDiagramURL.split(";", 0);		for(int i = 0; i < classDiagramURLSplit.length; i ++) {			for(int j = 0; j < mapValue.size(); j ++) {				String className = new String();				int index1 = classDiagramURLSplit[i].indexOf("!");				int index2 = classDiagramURLSplit[i].indexOf("!", index1+1);				if(index1 != -1 && index2 != -1 && !(classDiagramURLSplit[i].substring(index1+1, index2).contains("<"))) {					className = classDiagramURLSplit[i].substring(index1+1, index2);				}				if (className.equals(mapValue.get(j))) {					System.out.println("canvas_url : " + classDiagramURLSplit[i] + ", className : " + mapValue.get(j));					int att_index = -1, ope_index = -1;					boolean type_flag = false, att_flag = false, ope_flag = false;					String[] classDiagramURLSplit2 = classDiagramURLSplit[i].split("!", 0);					List<String> classDiagramURLSplitList = new ArrayList<String>();					classDiagramURLSplitList.addAll(Arrays.asList(classDiagramURLSplit2));					//クラスにステレオタイプが存在するかどうかチェック					if(classDiagramURLSplitList.get(1) != classDiagramURLSplitList.get(classDiagramURLSplitList.size() - 1))						if( ! (classDiagramURLSplitList.get(2).equals(""))) {							type_flag = true;						}						else {							type_flag = false;						}					else {}					System.out.println("List1 : " + classDiagramURLSplitList);					for(int k = 0; k < classDiagramURLSplitList.size(); k ++) {						//クラスに属性が存在するかチェック						if (classDiagramURLSplitList.get(k).contains("%") && ! (classDiagramURLSplitList.get(k).contains("("))) {							att_index = classDiagramURLSplitList.indexOf(classDiagramURLSplitList.get(k));							att_flag = true;						}						//クラスにメソッドが存在するかチェック						else if(classDiagramURLSplitList.get(k).contains("%") && classDiagramURLSplitList.get(k).contains("(")){							ope_index = classDiagramURLSplitList.indexOf(classDiagramURLSplitList.get(k));							ope_flag = true;						}					}					//パターン内の属性をクラスに追加					if( ! (attributeMap.isEmpty())) {						for(Map.Entry<String, String> entry : attributeMap.entrySet()) {							System.out.println("att_class_name ; " + mapValue.get(j) + ", " + entry.getKey());							if(mapValue.get(j).equals(entry.getKey())) {								if( ! (ope_flag)) {									classDiagramURLSplitList.add(entry.getValue());								}								else if (type_flag) {									if(att_index != -1) {										classDiagramURLSplitList.add(att_index + 1, entry.getValue());									}									else {										classDiagramURLSplitList.add(3, entry.getValue());									}								}								else {									classDiagramURLSplitList.add(classDiagramURLSplitList.indexOf(mapValue.get(j)) + 1, entry.getValue());								}								att_flag = true;								break;							}							else {}						}					}					else {}					//パターン内のメソッドをクラスに追加					if( ! (operationMap.isEmpty())) {						for(Map.Entry<String, String> entry : operationMap.entrySet()) {							if(mapValue.get(j).equals(entry.getKey())) {								System.out.println("ope_class_name ; " + mapValue.get(j) + ", " + entry.getKey());								classDiagramURLSplitList.add(entry.getValue());								ope_index = classDiagramURLSplitList.indexOf(classDiagramURLSplitList.get(classDiagramURLSplitList.size() - 1));								ope_flag =true;								break;							}							else {}						}					}					else {}					System.out.println("type_flag : " + type_flag + ", att_flag : " + att_flag + ", ope_flag : " + ope_flag);					if( ! (att_flag) && ! (ope_flag))	continue;					//空白の要素を削除					List<String> spaceList = new ArrayList<String>();					for(int k = 0; k < classDiagramURLSplitList.size(); k ++) {						if(classDiagramURLSplitList.get(k).equals("")) {							spaceList.add(classDiagramURLSplitList.get(k));						}					}					classDiagramURLSplitList.removeAll(spaceList);					System.out.println("List : " + classDiagramURLSplitList);					classDiagramURLSplit2 = classDiagramURLSplitList.toArray(new String[classDiagramURLSplitList.size()]);					StringBuilder builder = new StringBuilder();					//場合分けしてcanvas_urlを組み立てる					//URLにステレオタイプと属性が存在					if(type_flag && att_flag) {						for(int k = 0; k < classDiagramURLSplit2.length; k ++) {							builder.append(classDiagramURLSplit2[k]);							if(classDiagramURLSplit2[k] != classDiagramURLSplit2[classDiagramURLSplit2.length - 1]) {								if(classDiagramURLSplit2[k].contains("%")) {									if( ! (classDiagramURLSplit2[k].contains("(")) && classDiagramURLSplit2[k + 1].contains("(")) {										builder.append("!");									}								}								else {									builder.append("!");								}							}							else if( ! (ope_flag)) {								builder.append("!");							}							else {}						}					}					//URLにステレオタイプは存在するが属性は存在しない					else if(type_flag && ! (att_flag)) {						for(int k = 0; k < classDiagramURLSplit2.length; k ++) {							builder.append(classDiagramURLSplit2[k]);							if(classDiagramURLSplit2[k] != classDiagramURLSplit2[classDiagramURLSplit2.length - 1]) {								if( ! (classDiagramURLSplit2[k].contains("%")) && classDiagramURLSplit2[k+1].contains("%")) {									builder.append("!!");								}								else if(classDiagramURLSplit2[k].contains("%")){}								else {									builder.append("!");								}							}							else {}						}					}					//URLにステレオタイプは存在しないが属性は存在する					else if( ! (type_flag) && att_flag) {						for(int k = 0; k < classDiagramURLSplit2.length; k ++) {							builder.append(classDiagramURLSplit2[k]);							if(classDiagramURLSplit2[k] != classDiagramURLSplit2[classDiagramURLSplit2.length - 1]) {								if( ! (classDiagramURLSplit2[k].contains("%")) && classDiagramURLSplit2[k+1].contains("%")) {									builder.append("!!");								}								else if(classDiagramURLSplit2[k].contains("%") && classDiagramURLSplit2[k+1].contains("(")){									builder.append("!");								}								else if(classDiagramURLSplit2[k].contains("%")){}								else {									builder.append("!");								}							}							else if( ! (ope_flag)) {								builder.append("!");							}							else {}						}					}					//URLにステレオタイプ・属性ともに存在しない					else {						//メソッドが存在						if(ope_flag) {							for(int k = 0; k < classDiagramURLSplit2.length; k ++) {								builder.append(classDiagramURLSplit2[k]);								if(classDiagramURLSplit2[k] != classDiagramURLSplit2[classDiagramURLSplit2.length - 1]) {									if( ! (classDiagramURLSplit2[k].contains("(")) && classDiagramURLSplit2[k + 1].contains("(")) {										builder.append("!!!");									}									else if(classDiagramURLSplit2[k].contains("%")){}									else {										builder.append("!");									}								}								else {}							}						}						//メソッドが存在しない						else {							for(int k = 0; k < classDiagramURLSplit2.length; k ++) {								builder.append(classDiagramURLSplit2[k]);								if(classDiagramURLSplit2[k] != classDiagramURLSplit2[classDiagramURLSplit2.length - 1]) {									builder.append("!");								}								else {									builder.append("!!!");								}							}						}					}					classDiagramURLSplit[i] = builder.toString();					System.out.println("Split1 : " + classDiagramURLSplit[i]);				}			}		}		classDiagramURL = getBuilderURL(classDiagramURLSplit);		return classDiagramURL;	}	//削除したURLのIDを合成させたいクラスのIDに変更	private String getChangedCombineURL(String combineURL, Map<String, String> replaceIdMap) {		String combineURLSplit[] = combineURL.split(";", 0);		for(int i = 0; i < combineURLSplit.length; i ++) {			for(Map.Entry<String, String> entry : replaceIdMap.entrySet()) {				String combineURLSplit2[] = combineURLSplit[i].split("!", 0);				for(int j = 0; j < combineURLSplit2.length; j ++) {					String artifactId = new String();					int index1 = combineURLSplit2[j].lastIndexOf("<");					int index2 = combineURLSplit2[j].lastIndexOf(">");					if(index1 != -1 && index2 != -1) {						artifactId = combineURLSplit2[j].substring(index1, index2+1);					}					if(artifactId.equals(entry.getKey())) {						System.out.println("replaceId = " + entry.getKey() + ", targetId = " + entry.getValue());					    Pattern p = Pattern.compile(entry.getKey());					    Matcher m = p.matcher(combineURLSplit[i]);					    combineURLSplit[i] = m.replaceFirst(entry.getValue());						System.out.println("combineURLSplit = " + combineURLSplit[i]);					}				}			}		}		combineURL = getBuilderURL(combineURLSplit);		return combineURL;	}	//パターン追加処理	public String getPatternList(String studentId, int exercisesId, int listIndex) {		String pattern_url = new String();		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			String sql = "SELECT pattern_url FROM test_pattern where pattern_id = ?";			psmt = this.connection.prepareStatement(sql);			psmt.setInt(1, listIndex);			rs = psmt.executeQuery();			while(rs.next()) {				pattern_url = rs.getString("pattern_url");			}			rs.close();			psmt.close();		} catch(SQLException e) {            //エラーメッセージ出力            System.out.println( "Connection Failed. : " + e.toString() );		} catch(ExceptionInInitializerError error) {			error.getCause().printStackTrace();		} finally {			this.closeConnection(connection);		}		return pattern_url;	}	//パターンをデータベースに保存	public String savePatternList(String studentId, int exercisesId, String patternName, int patternId, List<String> spotList) {		String canvas_url = new String();		int pattern_id = 0;		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;		try {			//登録するcanvas_urlを取得			String sql = "select canvas_url from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc limit 1";			psmt = this.connection.prepareStatement(sql);			psmt.setString(1, studentId);			psmt.setInt(2, exercisesId);			rs = psmt.executeQuery();			while(rs.next()) {				canvas_url = rs.getString("canvas_url");			}			//パターンをデータベースへ登録			if(! (canvas_url.equals(""))) {				sql = "insert into test_pattern (pattern_id, pattern_name, pattern_url) values(?, ?, ?)";				psmt = this.connection.prepareStatement(sql);				psmt.setInt(1, patternId);				psmt.setString(2, patternName);				psmt.setString(3, canvas_url);				psmt.executeUpdate();			}			//登録したpattern_idを取得			sql = "SELECT MAX(pattern_id) FROM test_pattern";			psmt = this.connection.prepareStatement(sql);			rs = psmt.executeQuery();			while(rs.next()) {				pattern_id = rs.getInt("MAX(pattern_id)");			}			//spotをデータベースに登録			for(String str : spotList) {				sql = "insert into test_spot (spot_name, pattern_id) values(?, ?)";				psmt = this.connection.prepareStatement(sql);				psmt.setString(1, str);				psmt.setInt(2, pattern_id);				psmt.executeUpdate();			}			rs.close();			psmt.close();		} catch(SQLException e) {            //エラーメッセージ出力            System.out.println( "Connection Failed. : " + e.toString() );		} finally {			this.closeConnection(connection);		}		return patternName;	}	//saito add　---------------------------------------------------------------***		//現在開かれているクラス図のURLだけを取る	public String getStudent(String studentId, int exerciseId) {		String canvasUrl = null;		this.connection= this.createConnection();		try{			String sql = "select canvas_url from edit_event where student_id = ? and exercises_id = ? and canvas_url is not null order by edit_event_id desc limit 1";			PreparedStatement stmt = this.connection.prepareStatement(sql);			stmt.setString(1, studentId);			stmt.setInt(2, exerciseId);			ResultSet rs = stmt.executeQuery();			if(rs.first()){				canvasUrl = rs.getString("canvas_url");			}			stmt.close();			this.closeConnection(connection);		}catch(SQLException e){			this.closeConnection(connection);			e.printStackTrace();		} finally {		}		this.closeConnection(connection);		return canvasUrl;	}		//類似度(CSall,RSall)をDBに登録する	public void registerSimDB(String studentId, int exerciseId, double CSall, double RSall, int flag) {		this.connection = this.createConnection();		PreparedStatement psmt = null;		ResultSet rs = null;				System.out.println("cs::"+CSall+"      rs::"+RSall);		System.out.println("cds::"+ (CSall+RSall)/2 );				try {			String sql = "insert into similarity (student_id, exercise_id, CSall, RSall, times, flag) "					+ "values(?, ?, ?, ?, CURRENT_TIME, ?)";			psmt = this.connection.prepareStatement(sql);			psmt.setString(1, studentId);			psmt.setInt(2, exerciseId);			psmt.setDouble(3, CSall);			psmt.setDouble(4, RSall);			psmt.setInt(5, flag);						//flag  0＝類似度チェックのとき　　1＝チェックボタンを押したとき（再配置）			psmt.executeUpdate();			psmt.close();		} catch(SQLException e) {            System.out.println( "Connection Failed. : " + e.toString() );		} finally {			this.closeConnection(connection);		}	}		//kokubu add		// 開いているページと答えの図のcanvas_urlを取得		public String loadCanvasId(String studentId, int getexerciseId) {		//public String loadCanvasId(String studentId, int getexerciseId, String 成果物のクラス名,String 解答例のクラス名) {																						//対応してるクラス名↑		    String canvasUrl = null;		    String anscanvasUrl = null;		    //値渡しのできているか確認		    System.out.println("studentId:" + studentId);		    System.out.println("getexerciseId:" + getexerciseId);		    // データベースへの接続を確立	        this.connection = this.createConnection(); // メソッドはデータベース接続を作成するもの		    		    try {		        		        // SQL文を定義 - edit_event テーブルから canvas_url を取得		        String exerciseIdSql = "SELECT canvas_url FROM edit_event WHERE student_id = ? AND canvas_url IS NOT NULL ORDER BY edit_datetime DESC LIMIT 1";		        PreparedStatement exerciseIdStmt = this.connection.prepareStatement(exerciseIdSql);		        exerciseIdStmt.setString(1, studentId);		        ResultSet exerciseIdRs = exerciseIdStmt.executeQuery();		        String[] classNamepattern = new String[10];		        String[] splitcodeDB = new String[10];		        		        // 現在開いているページの edit_event から canvas_url を取得		        if (exerciseIdRs.next()) {		        	canvasUrl = exerciseIdRs.getString("canvas_url");		            		            // デコード前URLの出力		            System.out.println("デコード前：" + canvasUrl);		            // base64デコードするクラスを呼び出す		            canvasUrl = base64ToString(canvasUrl);			        			        // canvasUrlのデコードが上手くいった場合			        if (canvasUrl != null) {			        	// デコード後URLの出力				            System.out.println("ページurlをデコードした文字列：" + canvasUrl);			            			            // クラス名のみ抽出（テスト）			            splitcodeDB = canvasUrl.split(";",0);			            for(int i = 0; i< splitcodeDB.length;i++) {			            	System.out.println(i + "番目:" + splitcodeDB[i]);			            				            				            	classNamepattern[i] = getClassName(splitcodeDB, i);			            				            	if(classNamepattern[i] != null) {			            		System.out.println("クラス名" + i + ": " + classNamepattern[i]);			            	}			            				            				            }			            exerciseIdRs.close();				        exerciseIdStmt.close();			        } else {			            System.out.println("ページurlのデコードに失敗しました。");			        }		        }		        		        		        // getexerciseId を使用して answer から canvas_url を取得		        if (getexerciseId != -1) {		            String canvasUrlSql = "SELECT canvas_url FROM answer WHERE exercise_id = ?";		            PreparedStatement canvasUrlStmt = this.connection.prepareStatement(canvasUrlSql);		            canvasUrlStmt.setInt(1, getexerciseId);		            		            ResultSet canvasUrlRs = canvasUrlStmt.executeQuery();		            		            if (canvasUrlRs.next()) {		                anscanvasUrl = canvasUrlRs.getString("canvas_url");		                		                // base64デコードするクラスを呼び出す		                anscanvasUrl = base64ToString(anscanvasUrl);				        				        if (anscanvasUrl != null) {				            System.out.println("答えurlをデコードした文字列: " + anscanvasUrl);				            				        } else {				            System.out.println("答えurlのデコードに失敗しました。");				        }				        				        		            }		            canvasUrlRs.close();		            canvasUrlStmt.close();		            		            		            		            		         // 格納する値は渡された変数に変更が必要		            // 以下には成果物のクラス名を格納		            String exercisesclassname = "会議室";		            // 以下には解答例のクラス名を格納		            String ansclassname = "事務室";		            		            String coordinate  = getansCoordinate(anscanvasUrl, ansclassname);		            		            // 渡された成果物のクラス名と座標は以下に格納//		            String classname = クラス名;//		            String coordinate  = getansCoordinate(anscanvasUrl, classname);		            		            // 解答例座標の取得test//		            String test = getansCoordinate(anscanvasUrl, classname);		            System.out.println("座標チェック：" + coordinate);		            		            // 正規表現を使用してclassnameと一致する部分を検索		            Pattern pattern = Pattern.compile("\\(\\d+,\\d+\\)!" + Pattern.quote(exercisesclassname) + "!!");		            Matcher matcher = pattern.matcher(canvasUrl);		            boolean foundMatch = false; // マッチングが行われたかどうかを示すフラグ		            		            StringBuffer result = new StringBuffer();		            		            		            if(coordinate == null) {		            	System.out.println("answerの座標取得が上手くいってない");//		            	coordinate = exclusionclass(canvasUrl, exercisesclassname);		            }		            else {		            	while (matcher.find()) {			            	foundMatch = true; // マッチングが行われたことを示す			                // 一致する部分を置換			                String replacedText = "(" + coordinate + ")!" + exercisesclassname + "!!";			                matcher.appendReplacement(result, replacedText);			            }			            // 置換後のテキストを追加			            matcher.appendTail(result);		            }		            // マッチングをしているかの判定		            if (!foundMatch) {		            	// マッチング失敗時		            			            	if(coordinate == null) {		            		System.out.println("マッチング失敗");		            		canvasUrl = null;		            	}//		            	else//		            	{//		            		while (matcher.find()) {//				            	foundMatch = true; // マッチングが行われたことを示す//				                // 一致する部分を置換//				                String replacedText = "(" + coordinate + ")!" + classname + "!!";//				                matcher.appendReplacement(result, replacedText);//				            }//				            // 置換後のテキストを追加//				            matcher.appendTail(result);//				            //				            System.out.println("成果物の置換テスト：" + result);//			            	// ここでcanvasUrlに置換後のURLを格納//			            	canvasUrl = result.toString();		//		            	System.out.println("まとめたURL：" + canvasUrl);//		            	}		            			            } else {		            	 System.out.println("置換テスト：" + result);		            	 // ここでcanvasUrlに置換後のURLを格納		            	 canvasUrl = result.toString();			            	 System.out.println("まとめたURL：" + canvasUrl);		            }		            		            // canvasUrlをbase64エンコードしてURLとして使用可能にする	           	 	canvasUrl = encodebase64ToString(canvasUrl);		           	 	System.out.println("まとめたデコードURL：" + canvasUrl);		            		            //url変換テストここまで	    		        }		        		    } catch (SQLException e) {		        e.printStackTrace();		        this.closeConnection(connection); // このメソッドはデータベース接続をクローズするものと仮定します		    } finally {		        // データベース接続をクローズ		        this.closeConnection(connection); // このメソッドはデータベース接続をクローズするものと仮定します		    }		    return canvasUrl;		}						// 以下が解答例urlから座標を取得するメソッド		public String getansCoordinate(String url, String classname) {//			System.out.println("getansCoordinateの値渡しチェック");		//		System.out.println("url：" + url);		//		System.out.println("classname：" + classname);						// 正規表現を使用してclassnameと一致する部分を検索	        Pattern pattern = Pattern.compile("\\(\\d+,\\d+\\)!" + Pattern.quote(classname) + "!!");	        Matcher matcher = pattern.matcher(url);	        String coordinates = null;	        while (matcher.find()) {	            String match = matcher.group(); // マッチした部分を取得	            coordinates = match.replaceAll(".*\\(", "").replaceAll("\\)!.*", ""); // 座標の部分を抽出	        }						return coordinates;		}				public String exclusionclass(String url, String classname) {			// 正規表現を使用してclassnameと一致する部分を検索	        Pattern pattern = Pattern.compile("\\(\\d+,\\d+\\)!" + Pattern.quote(classname) + "!!");	        Matcher matcher = pattern.matcher(url);	        String coordinates = null;	        while (matcher.find()) {	            String match = matcher.group(); // マッチした部分を取得	            coordinates = match.replaceAll(".*\\(", "").replaceAll("\\)!.*", ""); // 座標の部分を抽出	        }	        	        return coordinates;		}				public String getClassName(String[] splitCodeDB, int index) {			Pattern pattern = Pattern.compile("Class\\$\\(\\d+,\\d+\\)!([^!]+)!!");	        Matcher matcher = pattern.matcher(splitCodeDB[index]);	        // クラス名を格納する配列	        String className = null;	        while (matcher.find()) {	            String temp = matcher.group(1);	            className = temp;	        }	        return className;		}
}

